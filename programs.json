{
  "categories": [
    {
      "id": 1,
      "name": "DSA",
      "description": "Data Structure and Algorithms using C",
      "programs": [
        {
          "id": 1.1,
          "title": "Linear Search",
          "description": "A simple search algorithm that checks each element of the array sequentially.",
          "content": "#include<stdio.h>\nvoid sequential_search(int a[],int n,int x)\n{\n    int i;\n    for(i=0;i<n;i++){\n        if(a[i]==x){\n            printf(\"Element found at index %d\",i);\n            return;\n        }\n    }\n    printf(\"Element not found\");\n}\nvoid main()\n{\n    int n,a[100],i,j,x,temp;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    \n    printf(\"Enter the element to be searched : \");\n    scanf(\"%d\",&x);\n    sequential_search(a,n,x);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 1.2,
          "title": "Binary Search",
          "description": "An efficient search algorithm that repeatedly divides a sorted array in half.",
          "content": "#include<stdio.h>\nvoid binary_search(int a[],int l,int r,int x)\n{\n    int mid;\n    while(l<=r){\n        mid=(l+r)/2;\n        if(x==a[mid]){\n            printf(\"Element found at index %d\",mid);\n            return;\n        }\n        if(x<a[mid]){\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    printf(\"Element not found\");\n}\nvoid main()\n{\n    int n,a[100],i,j,x,temp;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    \n    for(i=0;i<n-1;i++)          //sorting the array to perform binary search\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n        if(a[j]>a[j+1])\n        {\n            temp=a[j];\n            a[j]=a[j+1];\n            a[j+1]=temp;\n            }\n        }\n    }\n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    \n    printf(\"Enter the element to be searched : \");\n    scanf(\"%d\",&x);\n    binary_search(a,0,n-1,x);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 1.3,
          "title": "Interpolation Search",
          "description": "An improved variant of binary search suited for uniformly distributed arrays.",
          "content": "#include<stdio.h>\nvoid interpolation_search(int a[],int l,int r,int x)\n{\n    int mid;\n    while(l<=r){\n        mid=l+(r-l)*((x-a[l])/(a[r]-a[l]));\n        if(x==a[mid]){\n            printf(\"Element found at index %d\",mid);\n            return;\n        }\n        if(x<a[mid]){\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    printf(\"Element not found\");\n}\nvoid main()\n{\n    int n,a[100],i,j,x,temp;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    \n    for(i=0;i<n-1;i++)          //sorting the array to perform the interpolation search\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n        if(a[j]>a[j+1])\n        {\n            temp=a[j];\n            a[j]=a[j+1];\n            a[j+1]=temp;\n            }\n        }\n    }\n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    \n    printf(\"Enter the element to be searched : \");\n    scanf(\"%d\",&x);\n    interpolation_search(a,0,n-1,x);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 1.4,
          "title": "Quick Sort",
          "description": "A sorting algorithm that picks an element as a pivot and partitions the array around the pivot.",
          "content": "#include<stdio.h>\nvoid quick_sort(int a[],int low, int high)\n{\n    int i,j,temp,x;\n    if(low>=high)\n    return;\n    else{\n        x=a[low];\n        i=low+1;\n        j=high;\n        while(i<=j){\n        while(a[i]<x && i<=high){\n            i++;\n        }\n        while(a[j]>x && j>low){\n            j--;\n        }\n        if(i<j){\n            temp=a[i];\n            a[i]=a[j];\n            a[j]=temp;\n            i++;\n            j--;\n        }\n        }\n        a[low]=a[j];\n        a[j]=x;\n        \n        quick_sort(a,low,j-1);\n        quick_sort(a,j+1,high);\n    }\n}\nvoid main()\n{\n    int n,a[100],i;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"Array before sorting\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\\n\",a[i]);\n    }\n    printf(\"Array after sorting\\n\");\n    quick_sort(a,0,n-1);\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\\n\",a[i]);\n    }\n}",
          "created_at": null,
          "updated_at": null
        }
      ]
    },
    {
      "id": 2,
      "name": "OS",
      "description": "Operating System",
      "programs": [
        {
          "id": 2.1,
          "title": "FCFS with Arrival Time",
          "description": "FCFS stands for First Come First Serve. In the FCFS scheduling algorithm, the job that arrived first in the ready queue is allocated to the CPU and then the job that came second, and so on. FCFS is a non-preemptive scheduling algorithm as a process holds the CPU until it either terminates",
          "content": "#include<stdio.h>\nvoid main(){\n\tint bt[10]={0},at[10]={0},tat[10]={0},wt[10]={0},ct[10]={0},process_no[10],tempBT[10]={0};\n\tint n,sum=0,temp;\n\tfloat totalTAT=0,totalWT=0;\n\n\tprintf(\"Enter number of processes\t\");\n\tscanf(\"%d\",&n);\n\n\tprintf(\"Enter arrival time and burst time for each process\\n\\n\");\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t    process_no[i]=i+1;\n\t\tprintf(\"Arrival time of process[%d]\t\",i+1);\n\t\tscanf(\"%d\",&at[i]);\n\t\tprintf(\"Burst time of process[%d]\t\",i+1);\n\t\tscanf(\"%d\",&bt[i]);\n\t\ttempBT[i]=bt[i];\n\t\tprintf(\"\\n\");\n\t}\n\n\t//sorting based on arrival time\n\tfor(int i=0;i<n-1;i++){\n        for(int j=0;j<n-i-1;j++){\n            if(at[j]>at[j+1]){\n                temp=at[j];\n                at[j]=at[j+1];\n                at[j+1]=temp;\n\n                temp=bt[j];\n                bt[j]=bt[j+1];\n                bt[j+1]=temp;\n\n                temp=tempBT[j];\n                tempBT[j]=tempBT[j+1];\n                tempBT[j+1]=temp;\n\n                temp=process_no[j];\n                process_no[j]=process_no[j+1];\n                process_no[j+1]=temp;\n            }\n        }\n\t}\n\n\t//calculate completion time of processes\n\tint count=0;\n\twhile(count<n){\n        for(int j=0;j<n;j++)\n        {\n            x:\n            if(at[j]<=sum && tempBT[j]>0){\t//if the process has arrived in RQ\n            sum+=bt[j];\n            ct[j]+=sum;\n            count++;\n            tempBT[j]=0;\n            }\n            else{\n                sum++;\t\t//if the process has not arrived in RQ, increments sum (time) and goes back to label 'x'\n                goto x;\n            }\n        }\n\t}\n\n\t//calculate turnaround time and waiting times\n\tfor(int k=0;k<n;k++)\n\t{\n\t\ttat[k]=ct[k]-at[k];\n\t\ttotalTAT+=tat[k];\n\t}\n\tfor(int k=0;k<n;k++)\n\t{\n\t\twt[k]=tat[k]-bt[k];\n\t\ttotalWT+=wt[k];\n\t}\n\tprintf(\"Solution: \\n\\n\");\n\tprintf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\",process_no[i],at[i],bt[i],ct[i],tat[i],wt[i]);\n\t}\n\tprintf(\"\\n\\nAverage Turnaround Time = %f\\n\",totalTAT/n);\n\tprintf(\"Average WT = %f\\n\\n\",totalWT/n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 2.2,
          "title": "FCFS without Arrival Time",
          "description": "FCFS stands for First Come First Serve. In the FCFS scheduling algorithm, the job that arrived first in the ready queue is allocated to the CPU and then the job that came second, and so on. FCFS is a non-preemptive scheduling algorithm as a process holds the CPU until it either terminates",
          "content": "#include<stdio.h>\n\nvoid main(){\n\n\tint bt[10]={0},at[10]={0},tat[10]={0},wt[10]={0},ct[10]={0};\n\tint n,sum=0;\n\tfloat totalTAT=0,totalWT=0;\n\n\tprintf(\"Enter number of processes\t\");\n\tscanf(\"%d\",&n);\n\n\tprintf(\"Enter Burst time for each process\\n\\n\");\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"Burst time of process[%d]\t\",i+1);\n\t\tscanf(\"%d\",&bt[i]);\n\n\t\tprintf(\"\\n\");\n\t}\n\n\t//calculate completion time of processes\n\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tsum+=bt[j];\n\t\tct[j]+=sum;\n\t}\n\n\t//calculate turnaround time and waiting times\n\n\tfor(int k=0;k<n;k++)\n\t{\n\t\ttat[k]=ct[k]-at[k];\n\t\ttotalTAT+=tat[k];\n\t}\n\n\n\tfor(int k=0;k<n;k++)\n\t{\n\t\twt[k]=tat[k]-bt[k];\n\t\ttotalWT+=wt[k];\n\t}\n\n\tprintf(\"Solution: \\n\\n\");\n\tprintf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\",i+1,at[i],bt[i],ct[i],tat[i],wt[i]);\n\t}\n\n\tprintf(\"\\n\\nAverage Turnaround Time = %f\\n\",totalTAT/n);\n\tprintf(\"Average WT = %f\\n\\n\",totalWT/n);\n\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 2.3,
          "title": "SJF Non-Preemptive",
          "description": "In SJF scheduling, the process with the lowest burst time, among the list of available processes in the ready queue, is going to be scheduled next. In Non-preemptive SJF scheduling, once the process is scheduled cpu will be released only once the processes terminates",
          "content": "#include <stdio.h> void main() { int bt[10] = {0}, at[10] = {0}, tat[10] = {0}, wt[10] = {0}, ct[10] = {0},remaining_burst[10]; int n, time = 0, smallest, count = 0; float totalTAT = 0, totalWT = 0; printf(\"Enter number of processes \"); scanf(\"%d\", &n); printf(\"Enter arrival time and burst time for each process\\n\\n\"); for(int i = 0; i < n; i++) { printf(\"Arrival time of process[%d] \", i + 1); scanf(\"%d\", &at[i]); printf(\"Burst time of process[%d] \", i + 1); scanf(\"%d\", &bt[i]); remaining_burst[i] = bt[i]; printf(\"\\n\"); } while (count < n) { smallest = -1; for (int i = 0; i < n; i++) { if (at[i] <= time && remaining_burst[i] > 0) { if (smallest == -1 || remaining_burst[i] < remaining_burst[smallest]) { smallest = i; } } } if (smallest == -1) { time++; } else { time += bt[smallest]; ct[smallest] = time; tat[smallest] = ct[smallest] - at[smallest]; wt[smallest] = tat[smallest] - bt[smallest]; totalTAT += tat[smallest]; totalWT += wt[smallest]; remaining_burst[smallest] = 0; count++; } } printf(\"Solution: \\n\\n\"); printf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\"); for (int i = 0; i < n; i++) { printf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\", i+1, at[i], bt[i], ct[i], tat[i], wt[i]); } printf(\"\\n\\nAverage Turnaround Time = %f\\n\", totalTAT / n); printf(\"Average WT = %f\\n\\n\", totalWT / n); }",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 2.4,
          "title": "LRU Page Replacement",
          "description": "In Least Recently Used (LRU) algorithm, page will be replaced which is least recently used.",
          "content": "#include <stdio.h>\n#include <stdbool.h>\n\nbool isInMemory(int page, int memory[], int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        if (memory[i] == page)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid displayMemory(int memory[], int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", memory[i]);\n    }\n    printf(\"\\n\");\n}\n\nint LRU(int pages[], int memory[], int n, int maxFrames, int start)\n{\n    int index = -1, farthest = start + 1;\n\n    for (int i = 0; i < maxFrames; i++)\n    {\n        int j;\n        for (j = start; j >= 0; j--)\n        {\n            if (memory[i] == pages[j])\n            {\n                if (j < farthest)\n                {\n                    farthest = j;\n                    index = i;\n                }\n                break;\n            }\n        }\n        if (j == 0)\n        {\n            return i;\n        }\n    }\n\n    return (index == -1) ? 0 : index;\n}\n\nint main()\n{\n    int n;\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &n);\n\n    int pages[n];\n    printf(\"Enter the pages: \");\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &pages[i]);\n    }\n\n    int maxFrames;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &maxFrames);\n\n    int memory[maxFrames];\n    int faults = 0;\n\n    for (int i = 0; i < maxFrames; i++)\n    {\n        memory[i] = -1;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"Page: %d, Memory: \", pages[i]);\n        if (!isInMemory(pages[i], memory, maxFrames))\n        {\n            faults++;\n            if(maxFrames > i){\n                memory[i] = pages[i];\n            }else{\n                int pos = LRU(pages, memory, n, maxFrames, i - 1);\n                memory[pos] = pages[i];\n            }\n        }\n        displayMemory(memory, maxFrames);\n    }\n\n    printf(\"Total Page Faults: %d\\n\", faults);\n\n    return 0;\n}",
          "created_at": null,
          "updated_at": null
        }
      ]
    }
  ]
}
