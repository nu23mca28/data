{
  "categories": [
    {
      "id": 1,
      "name": "Data Structure and Algorithms",
      "description": "C programs for Searching and Sorting techniques",
      "backgroundImage": "https://png.pngtree.com/thumb_back/fh260/background/20201026/pngtree-structural-connection-of-information-data-transfer-in-network-connection-image_438814.jpg",
      "programs": [
        {
          "id": 11,
          "title": "Linear Search",
          "description": "A simple search algorithm that checks each element of the array sequentially.",
          "content": "#include<stdio.h>\nvoid sequential_search(int a[],int n,int x)\n{\n    int i;\n    for(i=0;i<n;i++){\n        if(a[i]==x){\n            printf(\"Element found at index %d\",i);\n            return;\n        }\n    }\n    printf(\"Element not found\");\n}\nvoid main()\n{\n    int n,a[100],i,j,x,temp;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    \n    printf(\"Enter the element to be searched : \");\n    scanf(\"%d\",&x);\n    sequential_search(a,n,x);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 12,
          "title": "Binary Search",
          "description": "An efficient search algorithm that repeatedly divides a sorted array in half.",
          "content": "#include<stdio.h>\nvoid binary_search(int a[],int l,int r,int x)\n{\n    int mid;\n    while(l<=r){\n        mid=(l+r)/2;\n        if(x==a[mid]){\n            printf(\"Element found at index %d\",mid);\n            return;\n        }\n        if(x<a[mid]){\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    printf(\"Element not found\");\n}\nvoid main()\n{\n    int n,a[100],i,j,x,temp;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    \n    for(i=0;i<n-1;i++)          //sorting the array to perform binary search\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n        if(a[j]>a[j+1])\n        {\n            temp=a[j];\n            a[j]=a[j+1];\n            a[j+1]=temp;\n            }\n        }\n    }\n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    \n    printf(\"Enter the element to be searched : \");\n    scanf(\"%d\",&x);\n    binary_search(a,0,n-1,x);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 13,
          "title": "Interpolation Search",
          "description": "An improved variant of binary search suited for uniformly distributed arrays.",
          "content": "#include<stdio.h>\nvoid interpolation_search(int a[],int l,int r,int x)\n{\n    int mid;\n    while(l<=r){\n        mid=l+(r-l)*((x-a[l])/(a[r]-a[l]));\n        if(x==a[mid]){\n            printf(\"Element found at index %d\",mid);\n            return;\n        }\n        if(x<a[mid]){\n            r=mid-1;\n        }\n        else{\n            l=mid+1;\n        }\n    }\n    printf(\"Element not found\");\n}\nvoid main()\n{\n    int n,a[100],i,j,x,temp;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    \n    for(i=0;i<n-1;i++)          //sorting the array to perform the interpolation search\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n        if(a[j]>a[j+1])\n        {\n            temp=a[j];\n            a[j]=a[j+1];\n            a[j+1]=temp;\n            }\n        }\n    }\n    \n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    \n    printf(\"Enter the element to be searched : \");\n    scanf(\"%d\",&x);\n    interpolation_search(a,0,n-1,x);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 14,
          "title": "Bubble Sort",
          "description": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.",
          "content": "#include<stdio.h>\nvoid bubble_sort(int a[],int n)\n{\n    int i,j,temp;\n    for(i=0;i<n-1;i++)\n    {\n        for(j=0;j<n-i-1;j++)\n        {\n        if(a[j]>a[j+1])\n        {\n            temp=a[j];\n            a[j]=a[j+1];\n            a[j+1]=temp;\n            }\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n}\nvoid main()\n{\nint n,a[100],i;\nprintf(\"Enter the number of elements in an array\\n\");\nscanf(\"%d\",&n);\nprintf(\"Enter array elements\\n\");\nfor(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"Array before sorting\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    printf(\"\\nArray after sorting\\n\");\n    bubble_sort(a,n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 15,
          "title": "Insertion Sort",
          "description": "A sorting algorithm where the array is divided into a sorted and an unsorted part, and each element is picked from the unsorted part and placed in its correct position in the sorted part.",
          "content": "#include<stdio.h>\nvoid insertion_sort(int a[],int n)\n{\n    int i,j,temp;\n    for(i=1;i<n;i++){\n        temp=a[i];\n        for(j=i-1;j>=0 && temp<a[j];j--){\n                a[j+1]=a[j];\n        }\n        a[j+1]=temp;\n    }\n    for(i=0;i<n;i++){\n        printf(\"%d \",a[i]);\n    }\n}\nvoid main()\n{\n    int n,a[100],i;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"Array before sorting\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\\n\",a[i]);\n    }\n    printf(\"Array after sorting\\n\");\n    insertion_sort(a,n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 16,
          "title": "Selection Sort",
          "description": "A sorting algorithm that repeatedly finds the minimum element from the unsorted part of the array and swaps it with the first unsorted element.",
          "content": "#include<stdio.h>\nvoid selection_sort(int a[],int n)\n{\n    int i,j,min,temp;\n    for(i=0;i<n-1;i++){\n        min=i;                  //assuming first element is lowest(in each iteration min stores the index of lowest element)\n        for(j=i+1;j<n;j++){\n            if(a[j]<a[min]){\n                min=j;          //storing the index of lowest elemnt\n            }\n        }\n        temp=a[i];              //swapping lowest value 'a[min]' with 'i' index \n        a[i]=a[min];\n        a[min]=temp;\n    }\n    for(i=0;i<n;i++){\n        printf(\"%d \",a[i]);\n    }\n}\nvoid main()\n{\n    int n,a[100],i;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"Array before sorting\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\\n\",a[i]);\n    }\n    printf(\"Array after sorting\\n\");\n    selection_sort(a,n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 17,
          "title": "Shell Sort",
          "description": "A sorting algorithm that starts by sorting pairs of elements far apart from each other, and progressively reduces the gap between elements to be compared.",
          "content": "#include<stdio.h>\nvoid shell_sort(int a[],int n,int increments[], int numinc)\n{\n    int i,j,k,span,temp;\n    for(k=0;k<numinc;k++)\n    {\n        span=increments[k];\n        for(i=span;i<n;i++){\n            temp=a[i];\n            for(j=i-span;j>=0 && temp<a[j];j=j-span){\n                a[j+span]=a[j];\n            }\n            a[j+span]=temp;\n        }\n    }\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n}\nvoid main()\n{\n    int n,a[100],i;\n    int increments[] = {5, 3, 1}; \n    int numinc = 3;\n    \n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"Array before sorting\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\",a[i]);\n    }\n    printf(\"\\nArray after sorting\\n\");\n    shell_sort(a, n, increments, numinc);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 18,
          "title": "Merge Sort",
          "description": "A sorting algorithm that divides the array into two halves, recursively sorts each half, and then merges the sorted halves.",
          "content": "#include<stdio.h>\nvoid merge(int A[],int l,int m,int r)\n{\n    int i,j,k;\n    int n1=m-l+1;\n    int n2=r-m;\n    int L[10],R[10];\n    \n    for(i=0;i<n1;i++)\n        L[i]=A[l+i];\n    \n    for(j=0;j<n2;j++)\n        R[j]=A[m+1+j];\n    \n    j=0;i=0;k=l;\n    \n    while(i<n1 && j<n2)\n    {\n        if(L[i]<=R[j])\n        {\n            A[k]=L[i];\n            i++;\n        }\n        else\n        {\n            A[k]=R[j];\n            j++;\n        }\n        k++;\n    } \n    \n    while(i<n1)\n    {\n        A[k]=L[i];\n        i++;\n        k++;\n    }\n    \n    while(j<n2)\n    {\n        A[k]=R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergesort(int A[], int l, int r)\n{ \n    if(l<r)\n    {\n        int m=(l+r)/2;\n        mergesort(A,l,m);\n        mergesort(A,m+1,r);\n        merge(A,l,m,r);\n    }\n}\nvoid main()\n{\n    int A[20],i,n;\n    printf(\"Enter the number of elements: \");\n    scanf(\"%d\",&n);\n    printf(\"Enter the elements : \\n\");\n    for(i=0;i<n;i++) \n        scanf(\"%d\",&A[i]);\n    mergesort(A,0,n-1);\n    printf(\"Array after merge sort : \\n\");\n    for(i=0;i<n;i++) \n        printf(\"%d\\n\", A[i]);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 19,
          "title": "Quick Sort",
          "description": "A sorting algorithm that picks an element as a pivot and partitions the array around the pivot.",
          "content": "#include<stdio.h>\nvoid quick_sort(int a[],int low, int high)\n{\n    int i,j,temp,x;\n    if(low>=high)\n    return;\n    else{\n        x=a[low];\n        i=low+1;\n        j=high;\n        while(i<=j){\n        while(a[i]<x && i<=high){\n            i++;\n        }\n        while(a[j]>x && j>low){\n            j--;\n        }\n        if(i<j){\n            temp=a[i];\n            a[i]=a[j];\n            a[j]=temp;\n            i++;\n            j--;\n        }\n        }\n        a[low]=a[j];\n        a[j]=x;\n        \n        quick_sort(a,low,j-1);\n        quick_sort(a,j+1,high);\n    }\n}\nvoid main()\n{\n    int n,a[100],i;\n    printf(\"Enter the number of elements in an array\\n\");\n    scanf(\"%d\",&n);\n    printf(\"Enter array elements\\n\");\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    printf(\"Array before sorting\\n\");\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\\n\",a[i]);\n    }\n    printf(\"Array after sorting\\n\");\n    quick_sort(a,0,n-1);\n    for(i=0;i<n;i++)\n    {\n        printf(\"%d\\t\\n\",a[i]);\n    }\n}",
          "created_at": null,
          "updated_at": null
        }
      ]
    },
    {
      "id": 2,
      "name": "Operating System",
      "description": "Process scheduling and Page replacement programs",
      "programs": [
        {
          "id": 21,
          "title": "FCFS with Arrival Time",
          "description": "FCFS stands for First Come First Serve. In the FCFS scheduling algorithm, the job that arrived first in the ready queue is allocated to the CPU and then the job that came second, and so on. FCFS is a non-preemptive scheduling algorithm as a process holds the CPU until it either terminates",
          "content": "#include<stdio.h>\nvoid main(){\n\tint bt[10]={0},at[10]={0},tat[10]={0},wt[10]={0},ct[10]={0},process_no[10],tempBT[10]={0};\n\tint n,sum=0,temp;\n\tfloat totalTAT=0,totalWT=0;\n\n\tprintf(\"Enter number of processes\t\");\n\tscanf(\"%d\",&n);\n\n\tprintf(\"Enter arrival time and burst time for each process\\n\\n\");\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t    process_no[i]=i+1;\n\t\tprintf(\"Arrival time of process[%d]\t\",i+1);\n\t\tscanf(\"%d\",&at[i]);\n\t\tprintf(\"Burst time of process[%d]\t\",i+1);\n\t\tscanf(\"%d\",&bt[i]);\n\t\ttempBT[i]=bt[i];\n\t\tprintf(\"\\n\");\n\t}\n\n\t//sorting based on arrival time\n\tfor(int i=0;i<n-1;i++){\n        for(int j=0;j<n-i-1;j++){\n            if(at[j]>at[j+1]){\n                temp=at[j];\n                at[j]=at[j+1];\n                at[j+1]=temp;\n\n                temp=bt[j];\n                bt[j]=bt[j+1];\n                bt[j+1]=temp;\n\n                temp=tempBT[j];\n                tempBT[j]=tempBT[j+1];\n                tempBT[j+1]=temp;\n\n                temp=process_no[j];\n                process_no[j]=process_no[j+1];\n                process_no[j+1]=temp;\n            }\n        }\n\t}\n\n\t//calculate completion time of processes\n\tint count=0;\n\twhile(count<n){\n        for(int j=0;j<n;j++)\n        {\n            x:\n            if(at[j]<=sum && tempBT[j]>0){\t//if the process has arrived in RQ\n            sum+=bt[j];\n            ct[j]+=sum;\n            count++;\n            tempBT[j]=0;\n            }\n            else{\n                sum++;\t\t//if the process has not arrived in RQ, increments sum (time) and goes back to label 'x'\n                goto x;\n            }\n        }\n\t}\n\n\t//calculate turnaround time and waiting times\n\tfor(int k=0;k<n;k++)\n\t{\n\t\ttat[k]=ct[k]-at[k];\n\t\ttotalTAT+=tat[k];\n\t}\n\tfor(int k=0;k<n;k++)\n\t{\n\t\twt[k]=tat[k]-bt[k];\n\t\ttotalWT+=wt[k];\n\t}\n\tprintf(\"Solution: \\n\\n\");\n\tprintf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\",process_no[i],at[i],bt[i],ct[i],tat[i],wt[i]);\n\t}\n\tprintf(\"\\n\\nAverage Turnaround Time = %f\\n\",totalTAT/n);\n\tprintf(\"Average WT = %f\\n\\n\",totalWT/n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 22,
          "title": "FCFS without Arrival Time",
          "description": "FCFS stands for First Come First Serve. In the FCFS scheduling algorithm, the job that arrived first in the ready queue is allocated to the CPU and then the job that came second, and so on. FCFS is a non-preemptive scheduling algorithm as a process holds the CPU until it either terminates",
          "content": "#include<stdio.h>\n\nvoid main(){\n\n\tint bt[10]={0},at[10]={0},tat[10]={0},wt[10]={0},ct[10]={0};\n\tint n,sum=0;\n\tfloat totalTAT=0,totalWT=0;\n\n\tprintf(\"Enter number of processes\t\");\n\tscanf(\"%d\",&n);\n\n\tprintf(\"Enter Burst time for each process\\n\\n\");\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"Burst time of process[%d]\t\",i+1);\n\t\tscanf(\"%d\",&bt[i]);\n\n\t\tprintf(\"\\n\");\n\t}\n\n\t//calculate completion time of processes\n\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tsum+=bt[j];\n\t\tct[j]+=sum;\n\t}\n\n\t//calculate turnaround time and waiting times\n\n\tfor(int k=0;k<n;k++)\n\t{\n\t\ttat[k]=ct[k]-at[k];\n\t\ttotalTAT+=tat[k];\n\t}\n\n\n\tfor(int k=0;k<n;k++)\n\t{\n\t\twt[k]=tat[k]-bt[k];\n\t\ttotalWT+=wt[k];\n\t}\n\n\tprintf(\"Solution: \\n\\n\");\n\tprintf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\",i+1,at[i],bt[i],ct[i],tat[i],wt[i]);\n\t}\n\n\tprintf(\"\\n\\nAverage Turnaround Time = %f\\n\",totalTAT/n);\n\tprintf(\"Average WT = %f\\n\\n\",totalWT/n);\n\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 23,
          "title": "SJF Non-Preemptive",
          "description": "In SJF scheduling, the process with the lowest burst time, among the list of available processes in the ready queue, is going to be scheduled next. In Non-preemptive SJF scheduling, once the process is scheduled cpu will be released only once the processes terminates",
          "content": "#include <stdio.h> void main() { int bt[10] = {0}, at[10] = {0}, tat[10] = {0}, wt[10] = {0}, ct[10] = {0},remaining_burst[10]; int n, time = 0, smallest, count = 0; float totalTAT = 0, totalWT = 0; printf(\"Enter number of processes \"); scanf(\"%d\", &n); printf(\"Enter arrival time and burst time for each process\\n\\n\"); for(int i = 0; i < n; i++) { printf(\"Arrival time of process[%d] \", i + 1); scanf(\"%d\", &at[i]); printf(\"Burst time of process[%d] \", i + 1); scanf(\"%d\", &bt[i]); remaining_burst[i] = bt[i]; printf(\"\\n\"); } while (count < n) { smallest = -1; for (int i = 0; i < n; i++) { if (at[i] <= time && remaining_burst[i] > 0) { if (smallest == -1 || remaining_burst[i] < remaining_burst[smallest]) { smallest = i; } } } if (smallest == -1) { time++; } else { time += bt[smallest]; ct[smallest] = time; tat[smallest] = ct[smallest] - at[smallest]; wt[smallest] = tat[smallest] - bt[smallest]; totalTAT += tat[smallest]; totalWT += wt[smallest]; remaining_burst[smallest] = 0; count++; } } printf(\"Solution: \\n\\n\"); printf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\"); for (int i = 0; i < n; i++) { printf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\", i+1, at[i], bt[i], ct[i], tat[i], wt[i]); } printf(\"\\n\\nAverage Turnaround Time = %f\\n\", totalTAT / n); printf(\"Average WT = %f\\n\\n\", totalWT / n); }",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 24,
          "title": "SJF Preemptive",
          "description": "In SJF scheduling, the process with the lowest burst time, among the list of available processes in the ready queue, is going to be scheduled next. In Preemptive SJF scheduling, cpu can be switched from one process to another process when a new process with shorter burst time arrives",
          "content": "#include <stdio.h>\n\nvoid main() {\n    int bt[10] = {0}, at[10] = {0}, tat[10] = {0}, wt[10] = {0}, ct[10] = {0}, remaining_burst[10];\n    int n, time = 0, smallest, count = 0, current_process = -1;\n    float totalTAT = 0, totalWT = 0;\n\n    printf(\"Enter number of processes \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter arrival time and burst time for each process\\n\\n\");\n\n    for(int i = 0; i < n; i++) {\n\n        printf(\"Arrival time of process[%d] \", i + 1);\n        scanf(\"%d\", &at[i]);\n\n        printf(\"Burst time of process[%d] \", i + 1);\n        scanf(\"%d\", &bt[i]);\n\n        remaining_burst[i] = bt[i];\n\n        printf(\"\\n\");\n    }\n\n    while (count < n) {\n        smallest = -1;\n\n        for (int i = 0; i < n; i++) {\n            if (at[i] <= time && remaining_burst[i] > 0) {\n                if (smallest == -1 || remaining_burst[i] < remaining_burst[smallest]) {\n                    smallest = i;\n                }\n            }\n        }\n\n        if (smallest == -1) {\n            time++;\n        } else {\n            if (current_process != -1 && remaining_burst[current_process] > 0 && remaining_burst[smallest] < remaining_burst[current_process]) {\n                ct[current_process] = time;\n                current_process = smallest;\n            } else if (current_process == -1) {\n                current_process = smallest;\n            }\n\n            remaining_burst[smallest]--;\n            time++;\n\n            if (remaining_burst[smallest] == 0) {\n                count++;\n                ct[smallest] = time;\n                tat[smallest] = ct[smallest] - at[smallest];\n                wt[smallest] = tat[smallest] - bt[smallest];\n\n                totalTAT += tat[smallest];\n                totalWT += wt[smallest];\n\n                current_process = -1;\n            }\n        }\n    }\n\n    printf(\"Solution: \\n\\n\");\n    printf(\"P#\\t AT\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t %d\\t %d\\t %d\\t %d\\t %d\\n\", i+1, at[i], bt[i], ct[i], tat[i], wt[i]);\n    }\n\n    printf(\"\\n\\nAverage Turnaround Time = %f\\n\", totalTAT / n);\n    printf(\"Average WT = %f\\n\\n\", totalWT / n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 25,
          "title": "Priority Preemptive",
          "description": "In Priority scheduling, there is a priority number assigned to each process. In some systems, the lower the number, the higher the priority. While, in the others, the higher the number, the higher will be the priority. The Process with the higher priority among the available processes is given the CPU. In Preemptive Priority scheduling, cpu can be switched from one process to another process when a new process with higher priority arrives",
          "content": "#include <stdio.h>\n\nvoid main() {\n    int bt[10] = {0}, at[10] = {0}, priority[10] = {0}, tat[10] = {0}, wt[10] = {0}, ct[10] = {0}, remaining_burst[10];\n    int n, time = 0, highest_priority, count = 0, current_process = -1;\n    float totalTAT = 0, totalWT = 0;\n\n    printf(\"Enter number of processes \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter arrival time, burst time, and priority for each process\\n\\n\");\n\n    for(int i = 0; i < n; i++) {\n\n        printf(\"Arrival time of process[%d] \", i + 1);\n        scanf(\"%d\", &at[i]);\n\n        printf(\"Burst time of process[%d] \", i + 1);\n        scanf(\"%d\", &bt[i]);\n\n        printf(\"Priority of process[%d] \", i + 1);\n        scanf(\"%d\", &priority[i]);\n\n        remaining_burst[i] = bt[i];\n\n        printf(\"\\n\");\n    }\n\n    while (count < n) {\n        highest_priority = -1;\n\n        for (int i = 0; i < n; i++) {\n            if (at[i] <= time && remaining_burst[i] > 0) {\n                if (highest_priority == -1 || priority[i] < priority[highest_priority]) {\n                    highest_priority = i;\n                }\n            }\n        }\n\n        if (highest_priority == -1) {\n            time++;\n        } else {\n            if (current_process != -1 && remaining_burst[current_process] > 0 && priority[highest_priority] < priority[current_process]) {\n                ct[current_process] = time;\n                current_process = highest_priority;\n            } else if (current_process == -1) {\n                current_process = highest_priority;\n            }\n\n            remaining_burst[highest_priority]--;\n            time++;\n\n            if (remaining_burst[highest_priority] == 0) {\n                count++;\n                ct[highest_priority] = time;\n                tat[highest_priority] = ct[highest_priority] - at[highest_priority];\n                wt[highest_priority] = tat[highest_priority] - bt[highest_priority];\n\n                totalTAT += tat[highest_priority];\n                totalWT += wt[highest_priority];\n\n                current_process = -1;\n            }\n        }\n    }\n\n    printf(\"Solution: \\n\\n\");\n    printf(\"P#\\t AT\\t BT\\t Priority\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t %d\\t %d\\t %d\\t\\t %d\\t %d\\t %d\\n\", i+1, at[i], bt[i], priority[i], ct[i], tat[i], wt[i]);\n    }\n\n    printf(\"\\n\\nAverage Turnaround Time = %f\\n\", totalTAT / n);\n    printf(\"Average WT = %f\\n\\n\", totalWT / n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 26,
          "title": "Priority Non-Preemptive",
          "description": "In Priority scheduling, there is a priority number assigned to each process. In some systems, the lower the number, the higher the priority. While, in the others, the higher the number, the higher will be the priority. The Process with the higher priority among the available processes is given the CPU. In Non-preemptive Priority scheduling, once the process is scheduled cpu will be released only once the processes terminates",
          "content": "#include <stdio.h>\n\nvoid main() {\n    int bt[10] = {0}, at[10] = {0}, priority[10] = {0}, tat[10] = {0}, wt[10] = {0}, ct[10] = {0},remaining_burst[10];\n    int n, time = 0, highest_priority, count = 0;\n    float totalTAT = 0, totalWT = 0;\n\n    printf(\"Enter number of processes \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter arrival time, burst time, and priority for each process\\n\\n\");\n\n    for(int i = 0; i < n; i++) {\n        printf(\"Arrival time of process[%d] \", i + 1);\n        scanf(\"%d\", &at[i]);\n\n        printf(\"Burst time of process[%d] \", i + 1);\n        scanf(\"%d\", &bt[i]);\n\n        printf(\"Priority of process[%d] \", i + 1);\n        scanf(\"%d\", &priority[i]);\n\n        remaining_burst[i] = bt[i];\n        printf(\"\\n\");\n    }\n\n    while (count < n) {\n        highest_priority = -1;\n\n        for (int i = 0; i < n; i++) {\n            if (at[i] <= time && remaining_burst[i] > 0) {\n                if (highest_priority == -1 || priority[i] < priority[highest_priority]) {\n                    highest_priority = i;\n                }\n            }\n        }\n\n        if (highest_priority == -1) {\n            time++;\n        } else {\n            time += bt[highest_priority];\n            ct[highest_priority] = time;\n            tat[highest_priority] = ct[highest_priority] - at[highest_priority];\n            wt[highest_priority] = tat[highest_priority] - bt[highest_priority];\n\n            totalTAT += tat[highest_priority];\n            totalWT += wt[highest_priority];\n\n            remaining_burst[highest_priority] = 0;\n            count++;\n        }\n    }\n\n    printf(\"Solution: \\n\\n\");\n    printf(\"P#\\t AT\\t BT\\t Priority\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t %d\\t %d\\t %d\\t\\t %d\\t %d\\t %d\\n\", i+1, at[i], bt[i], priority[i], ct[i], tat[i], wt[i]);\n    }\n\n    printf(\"\\n\\nAverage Turnaround Time = %f\\n\", totalTAT / n);\n    printf(\"Average WT = %f\\n\\n\", totalWT / n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 27,
          "title": "Round Robin",
          "description": "Round Robin is a CPU scheduling algorithm where each process is cyclically assigned a fixed time slot. It is the preemptive version of the First come First Serve CPU Scheduling algorithm.",
          "content": "#include <stdio.h>\n\nvoid main() {\n    int bt[10] = {0}, tat[10] = {0}, wt[10] = {0}, ct[10] = {0}, process_no[10];\n    int n, time_quantum, remaining_burst[10];\n    float totalTAT = 0, totalWT = 0;\n\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter time quantum: \");\n    scanf(\"%d\", &time_quantum);\n\n    printf(\"Enter burst time for each process\\n\\n\");\n\n    for(int i = 0; i < n; i++) {\n        process_no[i] = i + 1;\n\n        printf(\"Burst time of process[%d]: \", i + 1);\n        scanf(\"%d\", &bt[i]);\n\n        remaining_burst[i] = bt[i];\n\n        printf(\"\\n\");\n    }\n\n    int flag = 0;\n    int current_time = 0;\n    while (1) {\n        flag = 0;\n        for (int i = 0; i < n; i++) {\n            if (remaining_burst[i] > 0) {\n                flag = 1;\n                if (remaining_burst[i] > time_quantum) {\n                    current_time += time_quantum;\n                    remaining_burst[i] -= time_quantum;\n                } else {\n                    current_time += remaining_burst[i];\n                    remaining_burst[i] = 0;\n                    ct[i] = current_time;\n                    tat[i] = ct[i];\n                    wt[i] = tat[i] - bt[i];\n\n                    totalTAT += tat[i];\n                    totalWT += wt[i];\n                }\n            }\n        }\n        if (flag == 0) break;\n    }\n\n    printf(\"Solution: \\n\\n\");\n    printf(\"P#\\t BT\\t CT\\t TAT\\t WT\\t\\n\\n\");\n\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t %d\\t %d\\t %d\\t %d\\n\", process_no[i], bt[i], ct[i], tat[i], wt[i]);\n    }\n\n    printf(\"\\n\\nAverage Turnaround Time = %f\\n\", totalTAT / n);\n    printf(\"Average WT = %f\\n\\n\", totalWT / n);\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 28,
          "title": "Bankers Algorithm",
          "description": "Banker’s Algorithm is a resource allocation and deadlock avoidance algorithm. It also helps the operating system to successfully share the resources between all the processes. The banker's algorithm is named because it checks whether a person should be sanctioned a loan amount or not to help the bank system safely simulate allocation resources.",
          "content": "#include <stdio.h>\n\nvoid main()\n{\n    int n, m, i, j, k, alloc[10][10],max[10][10],need[10][10],avail[10];\n\n    printf(\"Enter the number of processes: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter the number of resources: \");\n    scanf(\"%d\", &m);\n\n    printf(\"Enter the values for allocation:\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&alloc[i][j]);\n        }\n    }\n\n    printf(\"Enter the values for max:\\n\");\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<m;j++)\n        {\n            scanf(\"%d\",&max[i][j]);\n            need[i][j] = max[i][j] - alloc[i][j];\n        }\n    }\n\n    printf(\"Enter the values for available:\\n\");\n    for(j=0;j<m;j++)\n    {\n        scanf(\"%d\",&avail[j]);\n    }\n\n    int f[n], ans[n], ind = 0;\n    for (k = 0; k < n; k++)\n    {\n        f[k] = 0;\n    }\n\n\n    int y = 0;\n    for (k = 0; k < n; k++)\n    {\n        for (i = 0; i < n; i++)\n        {\n            if (f[i] == 0)\n            {\n                int flag = 0;\n                for (j = 0; j < m; j++)\n                {\n                    if (need[i][j] > avail[j])\n                    {\n                        flag = 1;\n                        break;\n                    }\n                }\n\n                if (flag == 0)\n                {\n                    ans[ind++] = i;\n\n                    for (y = 0; y < m; y++)\n                        avail[y] += alloc[i][y];\n                    f[i] = 1;\n                }\n            }\n        }\n    }\n\n    int flag = 1;\n    for(int i=0;i<n;i++)\n    {\n        if(f[i]==0)\n        {\n            flag=0;\n            printf(\"The following system is not safe\");\n            break;\n        }\n    }\n\n    if(flag==1)\n    {\n        printf(\"Following is the SAFE Sequence\\n\");\n        for (i = 0; i < n - 1; i++)\n            printf(\" P%d ->\", ans[i]);\n        printf(\" P%d\", ans[n - 1]);\n    }\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 29,
          "title": "FIFO Page Replacement",
          "description": "First In First Out (FIFO) is the simplest page replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced page in the front of the queue is selected for removal.",
          "content": "#include <stdio.h>\n#include <stdbool.h>\n\nbool isInMemory(int page, int memory[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (memory[i] == page) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid displayMemory(int memory[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", memory[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n;\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &n);\n\n    int pages[n];\n    printf(\"Enter the pages: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &pages[i]);\n    }\n\n    int maxFrames;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &maxFrames);\n\n    int memory[maxFrames];\n    int faults = 0;\n    int frameIndex = 0;\n\n    for (int i = 0; i < maxFrames; i++) {\n        memory[i] = -1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"Page: %d, Memory: \", pages[i]);\n        if (!isInMemory(pages[i], memory, maxFrames)) {\n            faults++;\n            memory[frameIndex] = pages[i];\n            frameIndex = (frameIndex + 1) % maxFrames;\n        }\n        displayMemory(memory, maxFrames);\n    }\n\n    printf(\"Total Page Faults: %d\\n\", faults);\n\n    return 0;\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 210,
          "title": "Optimal Page Replacement",
          "description": "In this algorithm, pages are replaced which would not be used for the longest duration of time in the future.",
          "content": "#include <stdio.h>\n#include <stdbool.h>\n\nbool isInMemory(int page, int memory[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (memory[i] == page) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid displayMemory(int memory[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", memory[i]);\n    }\n    printf(\"\\n\");\n}\n\nint findOptimal(int pages[], int memory[], int n, int maxFrames, int start) {\n    int index = -1, farthest = start;\n    for (int i = 0; i < maxFrames; i++) {\n        int j;\n        for (j = start; j < n; j++) {\n            if (memory[i] == pages[j]) {\n                if (j > farthest) {\n                    farthest = j;\n                    index = i;\n                }\n                break;\n            }\n        }\n        if (j == n) {\n            return i;\n        }\n    }\n    return (index == -1) ? 0 : index;\n}\n\nint main() {\n    int n;\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &n);\n\n    int pages[n];\n    printf(\"Enter the pages: \");\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &pages[i]);\n    }\n\n    int maxFrames;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &maxFrames);\n\n    int memory[maxFrames];\n    int faults = 0;\n\n    for (int i = 0; i < maxFrames; i++) {\n        memory[i] = -1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        printf(\"Page: %d, Memory: \", pages[i]);\n        if (!isInMemory(pages[i], memory, maxFrames)) {\n            faults++;\n            if (maxFrames>i)\n                 memory[i] = pages[i];\n            else {\n            int pos = findOptimal(pages, memory, n, maxFrames, i + 1);\n            memory[pos] = pages[i];\n        }\n     } \n        displayMemory(memory, maxFrames);\n    }\n\n    printf(\"Total Page Faults: %d\\n\", faults);\n\n    return 0;\n}",
          "created_at": null,
          "updated_at": null
        },
        {
          "id": 211,
          "title": "LRU Page Replacement",
          "description": "In Least Recently Used (LRU) algorithm, page will be replaced which is least recently used.",
          "content": "#include <stdio.h>\n#include <stdbool.h>\n\nbool isInMemory(int page, int memory[], int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        if (memory[i] == page)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid displayMemory(int memory[], int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", memory[i]);\n    }\n    printf(\"\\n\");\n}\n\nint LRU(int pages[], int memory[], int n, int maxFrames, int start)\n{\n    int index = -1, farthest = start + 1;\n\n    for (int i = 0; i < maxFrames; i++)\n    {\n        int j;\n        for (j = start; j >= 0; j--)\n        {\n            if (memory[i] == pages[j])\n            {\n                if (j < farthest)\n                {\n                    farthest = j;\n                    index = i;\n                }\n                break;\n            }\n        }\n        if (j == 0)\n        {\n            return i;\n        }\n    }\n\n    return (index == -1) ? 0 : index;\n}\n\nint main()\n{\n    int n;\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &n);\n\n    int pages[n];\n    printf(\"Enter the pages: \");\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &pages[i]);\n    }\n\n    int maxFrames;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &maxFrames);\n\n    int memory[maxFrames];\n    int faults = 0;\n\n    for (int i = 0; i < maxFrames; i++)\n    {\n        memory[i] = -1;\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"Page: %d, Memory: \", pages[i]);\n        if (!isInMemory(pages[i], memory, maxFrames))\n        {\n            faults++;\n            if(maxFrames > i){\n                memory[i] = pages[i];\n            }else{\n                int pos = LRU(pages, memory, n, maxFrames, i - 1);\n                memory[pos] = pages[i];\n            }\n        }\n        displayMemory(memory, maxFrames);\n    }\n\n    printf(\"Total Page Faults: %d\\n\", faults);\n\n    return 0;\n}",
          "created_at": null,
          "updated_at": null
        }
      ]
    }
  ]
}
